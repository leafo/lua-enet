<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>lua-enet, Lua bindings for ENet</title>
	<style type="text/css">.l_string { color: #A16D43; }
.l_symbol, .l_bold_symbol { color: #B50C0C; }
.l_keyword { color: #0CB56C; }
.l_comment { color: #D74DBF; }
.l_fn_symbol { color: #8E4681; }
.l_proper, .l_self_var, .l_special { color: #30A0BD; }
.l_proper { font-weight: bold; }
.l_builtins { color: #707A34; }
.l_number  { color: #4958C3; }

body {
	background: #DBFF8E;
	margin: 0px;
	padding: 0px;
}

h1, h2, h3, h4 {
	font-family: sans-serif;
}

#head {
	padding: 10px 1em;
	background: #FFF2A7;
	border-bottom: 1px solid #FFF9CC;
	color: #443A00;
	text-shadow: 1px 1px 0px #FFFBE5;
}

#head h1 {
	padding: 0px;
	margin: 0px;
}

#main {
	margin-left: auto;
	margin-right: auto;
	width: 920px;
	background: white;
	border-left: 1px solid #BAD979;
	border-right: 1px solid #BAD979;
	-webkit-box-shadow: 0px 0px 10px #B8D677;
	-moz-box-shadow: 0px 0px 10px #B8D677;
	box-shadow: 0px 0px 10px #B8D677;
}

.inner {
	padding: .5em 1.5em;
	border-top: 1px solid #E3D795;
	border-bottom: 1px solid #C989DE;
}

.footer {
	padding: 8px 1em;
	border-top: 1px solid #F0C2FF;
	background: #E79DFF;
	font-family: sans-serif;
	color: #765082;
	text-shadow: 1px 1px 0px #F0C4FF;
	font-size: 12px;
	text-align: right;
}

h2 { color: #AACF04; }
h3 {
	color: #9A9E88;
	border-bottom: 1px solid #D6DBBD;
}

h3 code {
	color: #CF0447; 
	display: block;
	background: #FFD1E0;
	background: #FFCAB6;
	padding: 4px;
	margin-top: 2em;
}

.api h3 {
	border: 0px;
}

h2 + h3 code {
	margin-top: 0px;
}

a:link, a:visited {
	color: #0477CF;
}

a:hover {
	color: #0451CF;
}

pre {
	border: 1px solid #D8D8D8;
	padding: 1em;
	background: white;
	-webkit-box-shadow: 0px 0px 10px #D6D6D6;
	-moz-box-shadow: 0px 0px 10px #D6D6D6;
	box-shadow: 0px 0px 10px #D6D6D6;
}

.social {
	float: right;
	padding-top: 8px;
}

</style>
	
	
</head><body>

	<a href="http://github.com/leafo/lua-enet"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a>

	<div id="main">
		<div id="head">
			<h1>lua-enet</h1>
		</div>
		<div class="inner"><p><strong>lua-enet</strong> is a binding to the <a href="http://enet.bespin.org/">ENet</a> library for
Lua. ENet is a thin network communication layer over UDP that provides high
performance and reliable communication that is suitable for games. The
interface exposes an asynchronous way of creating clients and servers that is
easy to integrate into existing event loops.</p>

<p>To get an idea of how ENet works and what it provides have a look at 
<a href="http://enet.bespin.org/Features.html">Features and Achritecture</a> from the
original documentation.</p>

<p>		</p><ul>
		
			<li><a href="#download_and_install">Download &amp; Install</a></li>
		 <ul> 
			<li><a href="#linux_and_osx">Linux &amp; OSX</a></li>
		
			<li><a href="#windows">Windows</a></li>
		 </ul> 
			<li><a href="#tutorial">Tutorial</a></li>
		
			<li><a href="#reference">Reference</a></li>
		 <ul> 
			<li><a href="#enethost_createbind_address_peer_count_channel_count_in_bandwidth_out_bandwidth"><code>enet.host_create([bind_address, peer_count, channel_count, in_bandwidth, out_bandwidth])</code></a></li>
		
			<li><a href="#hostconnectaddress__channel_count_data"><code>host:connect(address [, channel_count, data])</code></a></li>
		
			<li><a href="#hostservicetimeout"><code>host:service([timeout])</code></a></li>
		
			<li><a href="#hostcheck_events"><code>host:check_events()</code></a></li>
		
			<li><a href="#hostflush"><code>host:flush()</code></a></li>
		
			<li><a href="#hostchannel_limitlimit"><code>host:channel_limit(limit)</code></a></li>
		
			<li><a href="#hostbandwidth_limitincoming_outgoing"><code>host:bandwidth_limit(incoming, outgoing)</code></a></li>
		
			<li><a href="#peersenddata__channel_flag"><code>peer:send(data [, channel, flag])</code></a></li>
		
			<li><a href="#peerdisconnectdata"><code>peer:disconnect([data])</code></a></li>
		
			<li><a href="#peerdisconnect_nowdata"><code>peer:disconnect_now([data])</code></a></li>
		
			<li><a href="#peerdisconnect_laterdata"><code>peer:disconnect_later([data])</code></a></li>
		
			<li><a href="#peerreset"><code>peer:reset()</code></a></li>
		
			<li><a href="#peerping"><code>peer:ping()</code></a></li>
		
			<li><a href="#peerthrottle_configureinterval_acceleration_deceleration"><code>peer:throttle_configure(interval, acceleration, deceleration)</code></a></li>
		
			<li><a href="#peerreceive"><code>peer:receive()</code></a></li>
		 </ul> 
			<li><a href="#license_mit">License (MIT)</a></li>
		
			<li><a href="#contact">Contact</a></li>
		
		</ul>
  <p></p>

<p><a name="install"></a></p>

<h2><a name="download_and_install"></a>Download &amp; Install</h2>

<h3><a name="linux_and_osx"></a>Linux &amp; OSX</h3>

<p>Before installing <strong>lua-enet</strong>, you must make sure you have
<a href="http://enet.bespin.org/">ENet</a> installed. Consult your systemâ€™s package
management.</p>

<p>If you've got <a href="http://www.luarocks.org/">Lua Rocks</a> then installation is very easy:</p>

<pre><code>$ luarocks install enet
</code></pre>

<p>Otherwise you can download the source can from GitHub:
<a href="https://github.com/leafo/lua-enet">https://github.com/leafo/lua-enet</a></p>

<h3><a name="windows"></a>Windows</h3>

<p>Prebuilt binaries are provided:<br>
</p>

<p>Download <a href="http://leafo.net/lua-enet/bin/lua-enet-1.0.zip">http://leafo.net/lua-enet/bin/lua-enet-1.0.zip</a>.<br>
Unzip and install alongside your Lua installation.</p>

<p><a name="tutorial"></a></p>

<h2><a name="tutorial"></a>Tutorial</h2>

<p>We'll need a client and a server. A server is a <em>host</em> bound to an address.
A client is an unbound <em>host</em> that connects to an address.
<code>enet.host_create</code> is used to create a new host. <code>host:service</code> is used to wait
for events and send packets. It can optionally have a specified timeout.</p>

<p>When <code>host:service</code> receives an event it returns an event object, which is a
plain Lua table. The <code>type</code> entry holds the kind of event as a string, and the
<code>peer</code> entry has the associated peer who triggered the event.</p>

<p>Using this information, we can make a simple echo server:</p>

<pre><code class="lua-code"><span class="l_comment">-- server.lua
</span><span class="l_builtins">require</span> <span class="l_string">"enet"</span>
<span class="l_keyword">local</span> <span class="l_atom">host</span> <span class="l_symbol">=</span> <span class="l_atom">enet</span><span class="l_symbol">.</span><span class="l_atom">host_create</span><span class="l_string">"localhost:6789"</span>
<span class="l_keyword">while</span> <span class="l_special">true</span> <span class="l_keyword">do</span>
    <span class="l_keyword">local</span> <span class="l_atom">event</span> <span class="l_symbol">=</span> <span class="l_atom">host</span><span class="l_symbol">:</span><span class="l_atom">service</span>(<span class="l_number">100</span>)
    <span class="l_keyword">if</span> <span class="l_atom">event</span> <span class="l_keyword">and</span> <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">type</span> <span class="l_symbol">=</span><span class="l_symbol">=</span> <span class="l_string">"receive"</span> <span class="l_keyword">then</span>
        <span class="l_builtins">print</span>(<span class="l_string">"Got message: "</span>, <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">data</span>, <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">peer</span>)
        <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">peer</span><span class="l_symbol">:</span><span class="l_atom">send</span>(<span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">data</span>)
    <span class="l_keyword">end</span>
<span class="l_keyword">end</span>
</code></pre>

<p>Data, whether sent or received, is always a Lua string. Primitive types can be
converted to a binary string to reduce the number of bytes sent by using a binary
serialization library.</p>

<p>The client for our server can be written like so:</p>

<pre><code class="lua-code"><span class="l_comment">-- client.lua
</span><span class="l_builtins">require</span> <span class="l_string">"enet"</span>
<span class="l_keyword">local</span> <span class="l_atom">host</span> <span class="l_symbol">=</span> <span class="l_atom">enet</span><span class="l_symbol">.</span><span class="l_atom">host_create</span>()
<span class="l_keyword">local</span> <span class="l_atom">server</span> <span class="l_symbol">=</span> <span class="l_atom">host</span><span class="l_symbol">:</span><span class="l_atom">connect</span>(<span class="l_string">"localhost:6789"</span>)

<span class="l_keyword">local</span> <span class="l_atom">done</span> <span class="l_symbol">=</span> <span class="l_special">false</span>
<span class="l_keyword">while</span> <span class="l_keyword">not</span> <span class="l_atom">done</span> <span class="l_keyword">do</span>
    <span class="l_keyword">local</span> <span class="l_atom">event</span> <span class="l_symbol">=</span> <span class="l_atom">host</span><span class="l_symbol">:</span><span class="l_atom">service</span>(<span class="l_number">100</span>)
    <span class="l_keyword">if</span> <span class="l_atom">event</span> <span class="l_keyword">then</span>
        <span class="l_keyword">if</span> <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">type</span> <span class="l_symbol">=</span><span class="l_symbol">=</span> <span class="l_string">"connect"</span> <span class="l_keyword">then</span>
            <span class="l_builtins">print</span>(<span class="l_string">"Connected to"</span>, <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">peer</span>)
            <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">peer</span><span class="l_symbol">:</span><span class="l_atom">send</span>(<span class="l_string">"hello world"</span>)
        <span class="l_keyword">elseif</span> <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">type</span> <span class="l_symbol">=</span><span class="l_symbol">=</span> <span class="l_string">"receive"</span> <span class="l_keyword">then</span>
            <span class="l_builtins">print</span>(<span class="l_string">"Got message: "</span>, <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">data</span>, <span class="l_atom">event</span><span class="l_symbol">.</span><span class="l_atom">peer</span>)
            <span class="l_atom">done</span> <span class="l_symbol">=</span> <span class="l_special">true</span>
        <span class="l_keyword">end</span>
    <span class="l_keyword">end</span>
<span class="l_keyword">end</span>

<span class="l_atom">server</span><span class="l_symbol">:</span><span class="l_atom">disconnect</span>()
<span class="l_atom">host</span><span class="l_symbol">:</span><span class="l_atom">flush</span>()
</code></pre>

<p>Upon receiving the connect message we send <code>"hello world"</code> to the server, then
wait for the response.</p>

<p>When a client disconnects, make sure to call <code>disconnect</code> on the server object,
and then tell the host to flush (unless <code>host:service</code> will be called again)
otherwise the server will have to wait for the client to disconnect from timeout.</p>

<p><a name="reference"></a>
</p><div class="api"><p></p>

<h2><a name="reference"></a>Reference</h2>

<h3><a name="enethost_createbind_address_peer_count_channel_count_in_bandwidth_out_bandwidth"></a><code>enet.host_create([bind_address, peer_count, channel_count, in_bandwidth, out_bandwidth])</code></h3>

<p>Returns a new host. All arguments are optional.</p>

<p>A <code>bind_address</code> of <code>nil</code> makes a host that can not be connected to (typically
a client).  Otherwise the address can either be of the form
<code>&lt;ipaddress&gt;:&lt;port&gt;</code>, <code>&lt;hostname&gt;:&lt;port&gt;</code>, or <code>*:&lt;port&gt;</code>.</p>

<p>Example addresses include <code>"127.0.0.1:8888"</code>, <code>"localhost:2232"</code>, and <code>"*:6767"</code>.</p>

<p>Parameters:</p>

<ul>
<li><code>peer_count</code> max number of peers, defaults to <code>64</code></li>
<li><code>channel_count</code> max number of channels, defaults to <code>1</code></li>
<li><code>in_bandwidth</code> downstream bandwidth in bytes/sec, defaults to <code>0</code>
(unlimited)</li>
<li><code>out_bandwidth</code> upstream bandwidth in bytes/sec, defaults to <code>0</code>
(unlimited)</li>
</ul>


<h3><a name="hostconnectaddress__channel_count_data"></a><code>host:connect(address [, channel_count, data])</code></h3>

<p>Connects a host to a remote host. Returns peer object associated with remote
host.  The actual connection will not take place until the next <code>host:service</code>
is done, in which a <code>"connect"</code> event will be generated.</p>

<p><code>channel_count</code> is the number of channels to allocate. It should be the same as
the channel count on the server. Defaults to <code>1</code>.</p>

<p><code>data</code> is an integer value that can be associated with the connect event.
Defaults to <code>0</code>.</p>

<h3><a name="hostservicetimeout"></a><code>host:service([timeout])</code></h3>

<p>Wait for events, send and receive any ready packets. <code>timeout</code> is the max
number of milliseconds to be waited for an event. By default <code>timeout</code> is <code>0</code>.
Returns <code>nil</code> on timeout if no events occurred.</p>

<p>If an event happens, an event table is returned. All events have a <code>type</code> entry,
which is one of <code>"connect"</code>, <code>"disconnect"</code>, or <code>"receive"</code>. Events also have a
<code>peer</code> entry which holds the peer object of who triggered the event.</p>

<p>A <code>"receive"</code> event also has a <code>data</code> entry which is a Lua string containing the
data received.</p>

<h3><a name="hostcheck_events"></a><code>host:check_events()</code></h3>

<p>Checks for any queued events and dispatches one if available. Returns the
associated event if something was dispatched, otherwise <code>nil</code>.</p>

<h3><a name="hostflush"></a><code>host:flush()</code></h3>

<p>Sends any queued packets. This is only required to send packets earlier than
the next call to <code>host:service</code>, or if <code>host:service</code> will not be called again.</p>

<h3><a name="hostchannel_limitlimit"></a><code>host:channel_limit(limit)</code></h3>

<p>Sets the maximum number of channels allowed. If it is <code>0</code> then the system
maximum allowable value is used.</p>

<h3><a name="hostbandwidth_limitincoming_outgoing"></a><code>host:bandwidth_limit(incoming, outgoing)</code></h3>

<p>Sets the bandwidth limits of the host in bytes/sec. Set to <code>0</code> for unlimited.</p>

<h3><a name="peersenddata__channel_flag"></a><code>peer:send(data [, channel, flag])</code></h3>

<p>Queues a packet to be sent to peer. <code>data</code> is the contents of the packet, it
must be a Lua string.</p>

<p><code>channel</code> is the channel to send the packet on. Defaults to <code>0</code>.</p>

<p><code>flag</code> is one of <code>"reliable"</code>, <code>"unsequenced"</code>, or <code>"unreliable"</code>. Reliable
packets are guaranteed to arrive, and arrive in the order in which they are sent.
Unsequenced packets are unreliable and have no guarantee on the order they
arrive. Defaults to reliable.</p>

<h3><a name="peerdisconnectdata"></a><code>peer:disconnect([data])</code></h3>

<p>Requests a disconnection from the peer. The message is sent on the next
<code>host:service</code> or <code>host:flush</code>.</p>

<p><code>data</code> is optional integer value to be associated with the disconnect.</p>

<h3><a name="peerdisconnect_nowdata"></a><code>peer:disconnect_now([data])</code></h3>

<p>Force immediate disconnection from peer. Foreign peer not guaranteed to receive
disconnect notification.</p>

<p><code>data</code> is optional integer value to be associated with the disconnect.</p>

<h3><a name="peerdisconnect_laterdata"></a><code>peer:disconnect_later([data])</code></h3>

<p>Request a disconnection from peer, but only after all queued outgoing packets
are sent.</p>

<p><code>data</code> is optional integer value to be associated with the disconnect.</p>

<h3><a name="peerreset"></a><code>peer:reset()</code></h3>

<p>Forcefully disconnects peer. The peer is not notified of the disconnection.</p>

<h3><a name="peerping"></a><code>peer:ping()</code></h3>

<p>Send a ping request to peer, updates <code>round_trip_time</code>. This is called
automatically at regular intervals.</p>

<h3><a name="peerthrottle_configureinterval_acceleration_deceleration"></a><code>peer:throttle_configure(interval, acceleration, deceleration)</code></h3>

<p>Changes the probability at which unreliable packets should not be dropped.</p>

<p>Parameters:</p>

<ul>
<li><code>interval</code> interval in milliseconds to measure lowest mean RTT</li>
<li><code>acceleration</code> rate at which to increase throttle probability as mean RTT
declines</li>
<li><code>deceleration</code> rate at which to decrease throttle probability as mean RTT
increases</li>
</ul>


<h3><a name="peerreceive"></a><code>peer:receive()</code></h3>

<p>Attempts to dequeue an incoming packet for this peer.
Returns <code>nil</code> if there are no packets waiting. Otherwise returns two values:
the string representing the packet data, and the channel the packet came from.
</p></div><p></p>

<p><a name="license"></a></p>

<h2><a name="license_mit"></a>License (MIT)</h2>

<pre><code>Copyright (C) 2011 by Leaf Corcoran

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</code></pre>

<p><a name="contact"></a></p>

<h2><a name="contact"></a>Contact</h2>

<p>Author: Leaf Corcoran (<a href="http://github.com/leafo">leafo</a>) (<a href="http://twitter.com/moonscript">@moonscript</a>)<br>
Email: <a href="mailto:leafot@gmail.com">leafot@gmail.com</a><br>
Homepage: <a href="http://leafo.net">http://leafo.net</a><br>
</p>
</div>
		<div class="footer">Generated on Sat Sep  3 13:49:50 2011</div>
	</div>

	


</body>
</html>
